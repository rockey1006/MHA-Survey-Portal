# frozen_string_literal: true

# Prunes CSS selectors that reference unused CSS classes.
#
# It uses tmp/unused_css_classes_report.txt generated by script/find_unused_css_classes.rb
# and rewrites app/assets/stylesheets/**/*.css.
#
# Conservative behavior:
# - For a normal style rule, if a selector (within a comma-separated selector list)
#   contains ANY unused class token, that selector is dropped.
# - If all selectors are dropped, the whole rule is removed.
# - For @media/@supports/etc blocks, it recursively prunes inner rules.
# - Declarations are preserved verbatim; only selector lists and whole rules are removed.
#
# Notes:
# - This is a best-effort lightweight parser (not a full CSS parser).

require "pathname"
require "set"

ROOT = Pathname.new(__dir__).join("..").expand_path
REPORT_PATH = ROOT.join("tmp", "unused_css_classes_report.txt")
CSS_DIR = ROOT.join("app", "assets", "stylesheets")

CLASS_TOKEN_REGEX = /\.[a-zA-Z_][a-zA-Z0-9_-]*/

unless REPORT_PATH.exist?
  warn "Missing report at #{REPORT_PATH}. Run script/find_unused_css_classes.rb first."
  exit 1
end

unused_classes = Set.new
REPORT_PATH.read.each_line do |line|
  # lines look like: - class-name    (defined in: ...)
  next unless line.start_with?("- ")
  class_name = line.split.first.delete_prefix("-")
  class_name = class_name.strip
  next if class_name.empty?
  unused_classes << class_name
end

# Split by commas but respect (), [], and {} nesting inside selector prelude.
def split_selectors(prelude)
  parts = []
  buf = +""
  paren = 0
  bracket = 0
  brace = 0

  prelude.each_char do |ch|
    case ch
    when "("
      paren += 1
    when ")"
      paren -= 1 if paren.positive?
    when "["
      bracket += 1
    when "]"
      bracket -= 1 if bracket.positive?
    when "{"
      brace += 1
    when "}"
      brace -= 1 if brace.positive?
    when ","
      if paren.zero? && bracket.zero? && brace.zero?
        parts << buf
        buf = +""
        next
      end
    end

    buf << ch
  end

  parts << buf unless buf.empty?
  parts
end

# Remove selectors that reference unused classes.
def prune_selector_list(prelude, unused_classes)
  selectors = split_selectors(prelude)

  kept = selectors.filter do |sel|
    classes = sel.scan(CLASS_TOKEN_REGEX).map { |m| m.delete_prefix(".") }
    classes.none? { |c| unused_classes.include?(c) }
  end

  # Preserve original whitespace as best-effort by joining with comma+space.
  [kept.map(&:strip).reject(&:empty?).join(", "), selectors.size, kept.size]
end

# Lightweight recursive block parser: returns [new_text, removed_rules, removed_selectors, total_rules]
def prune_css(text, unused_classes)
  out = +""
  i = 0
  n = text.length
  removed_rules = 0
  removed_selectors = 0
  total_rules = 0

  # Helper: skip whitespace
  skip_ws = lambda do
    i += 1 while i < n && text.getbyte(i) <= 32
  end

  # Helper: consume comment verbatim
  consume_comment = lambda do
    start = i
    i += 2 # /*
    while i + 1 < n && !(text.getbyte(i) == 42 && text.getbyte(i + 1) == 47)
      i += 1
    end
    i += 2 if i + 1 < n
    out << text[start...i]
  end

  while i < n
    # Copy comments verbatim
    if i + 1 < n && text.getbyte(i) == 47 && text.getbyte(i + 1) == 42
      consume_comment.call
      next
    end

    # If we're at a closing brace, emit and return (caller handles)
    if text.getbyte(i) == 125 # }
      out << "}"
      i += 1
      break
    end

    # Capture any leading whitespace/newlines
    leading_start = i
    skip_ws.call
    leading = text[leading_start...i]

    # EOF
    break if i >= n

    # Read prelude until next '{' or '}'
    prelude_start = i
    in_string = nil
    while i < n
      ch = text.getbyte(i)

      # handle comments inside prelude
      if i + 1 < n && ch == 47 && text.getbyte(i + 1) == 42
        # emit leading + prelude so far, then comment, then continue
        out << leading
        out << text[prelude_start...i]
        consume_comment.call
        leading = ""
        prelude_start = i
        next
      end

      if in_string
        if ch == in_string
          in_string = nil
        elsif ch == 92 # backslash
          i += 1 # skip escaped
        end
        i += 1
        next
      end

      if ch == 34 || ch == 39
        in_string = ch
        i += 1
        next
      end

      break if ch == 123 || ch == 125
      i += 1
    end

    prelude = text[prelude_start...i].to_s.strip

    # If we hit a '}' without a block, emit and continue
    if i < n && text.getbyte(i) == 125
      out << leading
      out << text[prelude_start..i]
      i += 1
      next
    end

    # If no '{', just emit remainder
    if i >= n || text.getbyte(i) != 123
      out << leading
      out << text[prelude_start...n]
      break
    end

    # Now we are at '{'
    i += 1

    # Extract block contents (including nested braces)
    block_start = i
    depth = 1
    in_string = nil
    while i < n && depth.positive?
      ch = text.getbyte(i)

      if i + 1 < n && ch == 47 && text.getbyte(i + 1) == 42
        # skip comment
        i += 2
        while i + 1 < n && !(text.getbyte(i) == 42 && text.getbyte(i + 1) == 47)
          i += 1
        end
        i += 2 if i + 1 < n
        next
      end

      if in_string
        if ch == in_string
          in_string = nil
        elsif ch == 92
          i += 1
        end
        i += 1
        next
      end

      if ch == 34 || ch == 39
        in_string = ch
        i += 1
        next
      end

      if ch == 123
        depth += 1
      elsif ch == 125
        depth -= 1
      end

      i += 1
    end

    block = text[block_start...(i - 1)].to_s

    if prelude.start_with?("@")
      # Recurse into at-rule blocks
      inner, rr, rs, tr = prune_css(block, unused_classes)
      removed_rules += rr
      removed_selectors += rs
      total_rules += tr

      # If inner is effectively empty (only whitespace/comments), drop the at-rule
      inner_stripped = inner.gsub(%r{/\*.*?\*/}m, "").strip
      if inner_stripped.empty?
        removed_rules += 1
        next
      end

      out << leading
      out << prelude
      out << " {"
      out << inner
      out << "}"
      next
    end

    total_rules += 1

    new_prelude, original_selector_count, kept_selector_count = prune_selector_list(prelude, unused_classes)
    removed_selectors += (original_selector_count - kept_selector_count)

    if new_prelude.strip.empty?
      removed_rules += 1
      next
    end

    out << leading
    out << new_prelude
    out << " {"
    out << block
    out << "}"
  end

  [out, removed_rules, removed_selectors, total_rules]
end

css_files = Dir.glob(CSS_DIR.join("**", "*.css").to_s).map { |p| Pathname.new(p) }

grand_removed_rules = 0
grand_removed_selectors = 0
grand_total_rules = 0

css_files.each do |path|
  original = path.read
  pruned, removed_rules, removed_selectors, total_rules = prune_css(original, unused_classes)

  next if pruned == original

  path.write(pruned)

  rel = path.relative_path_from(ROOT).to_s
  puts "Pruned #{rel}: removed rules=#{removed_rules}, removed selectors=#{removed_selectors}, total rules=#{total_rules}"

  grand_removed_rules += removed_rules
  grand_removed_selectors += removed_selectors
  grand_total_rules += total_rules
end

puts "Done. Removed rules=#{grand_removed_rules}, removed selectors=#{grand_removed_selectors}."
