# frozen_string_literal: true

# Delete-only pruning of unused CSS.
#
# Reads tmp/unused_css_classes_report.txt (generated by script/find_unused_css_classes.rb)
# and removes CSS rules for which *all* selectors in the selector list contain at least
# one unused class.
#
# This approach is conservative and produces minimal diffs:
# - It never rewrites declarations or selector formatting.
# - It only deletes whole rules (or whole @-rule blocks if their contents become empty).
#
# It will not remove partially-unused selector lists (e.g., `.a, .b {}` where only `.b`
# is unused). Those can be cleaned up later if desired.

require "pathname"
require "set"

ROOT = Pathname.new(__dir__).join("..").expand_path
REPORT_PATH = ROOT.join("tmp", "unused_css_classes_report.txt")
CSS_DIR = ROOT.join("app", "assets", "stylesheets")

CLASS_TOKEN_REGEX = /\.[a-zA-Z_][a-zA-Z0-9_-]*/

unless REPORT_PATH.exist?
  warn "Missing report at #{REPORT_PATH}. Run script/find_unused_css_classes.rb first."
  exit 1
end

unused_classes = Set.new
REPORT_PATH.read.each_line do |line|
  next unless line.start_with?("- ")
  class_name = line[2..].to_s.strip
  class_name = class_name.split.first.to_s
  next if class_name.empty?
  unused_classes << class_name
end

# Split selector list by commas while respecting (), [], and {}.
def split_selectors(prelude)
  parts = []
  buf = +""
  paren = 0
  bracket = 0
  brace = 0
  in_string = nil

  prelude.each_char do |ch|
    if in_string
      if ch == in_string
        in_string = nil
      elsif ch == "\\"
        buf << ch
        next
      end
      buf << ch
      next
    end

    if ch == '"' || ch == "'"
      in_string = ch
      buf << ch
      next
    end

    case ch
    when "("
      paren += 1
    when ")"
      paren -= 1 if paren.positive?
    when "["
      bracket += 1
    when "]"
      bracket -= 1 if bracket.positive?
    when "{"
      brace += 1
    when "}"
      brace -= 1 if brace.positive?
    when ","
      if paren.zero? && bracket.zero? && brace.zero?
        parts << buf
        buf = +""
        next
      end
    end

    buf << ch
  end

  parts << buf
  parts
end

# True if selector contains at least one unused class token.
def selector_contains_unused_class?(selector, unused_classes)
  selector.scan(CLASS_TOKEN_REGEX).any? do |m|
    unused_classes.include?(m.delete_prefix("."))
  end
end

# True if the whole rule is removable (all selectors contain at least one unused class).
def removable_rule?(prelude, unused_classes)
  selectors = split_selectors(prelude)
  selectors.all? { |sel| selector_contains_unused_class?(sel, unused_classes) }
end

# Strip comments for "emptiness" detection
def strip_comments(text)
  text.gsub(%r{/\*.*?\*/}m, "")
end

# Returns [new_text, removed_rules]
def prune_block(text, unused_classes)
  i = 0
  n = text.length
  out = +""
  removed_rules = 0

  while i < n
    # Copy comments verbatim
    if i + 1 < n && text.getbyte(i) == 47 && text.getbyte(i + 1) == 42
      start = i
      i += 2
      while i + 1 < n && !(text.getbyte(i) == 42 && text.getbyte(i + 1) == 47)
        i += 1
      end
      i += 2 if i + 1 < n
      out << text[start...i]
      next
    end

    # If we hit a closing brace, we're done at this nesting level
    if text.getbyte(i) == 125 # }
      out << text[i..]
      break
    end

    # Find next '{' at this level
    prelude_start = i
    in_string = nil
    while i < n
      # comments in prelude
      if i + 1 < n && text.getbyte(i) == 47 && text.getbyte(i + 1) == 42
        break
      end

      ch = text.getbyte(i)

      if in_string
        if ch == in_string
          in_string = nil
        elsif ch == 92
          i += 1
        end
        i += 1
        next
      end

      if ch == 34 || ch == 39
        in_string = ch
        i += 1
        next
      end

      break if ch == 123 || ch == 125
      i += 1
    end

    # If we stopped because of a comment, copy up to it and then loop
    if i + 1 < n && text.getbyte(i) == 47 && text.getbyte(i + 1) == 42
      out << text[prelude_start...i]
      next
    end

    # If we reached end or '}' without a block, just copy
    if i >= n || text.getbyte(i) == 125
      out << text[prelude_start...i]
      next
    end

    # We are at '{'
    prelude_end = i
    prelude = text[prelude_start...prelude_end]

    # Find matching closing brace for this block
    i += 1
    block_start = i
    depth = 1
    in_string = nil

    while i < n && depth.positive?
      # skip comments
      if i + 1 < n && text.getbyte(i) == 47 && text.getbyte(i + 1) == 42
        i += 2
        while i + 1 < n && !(text.getbyte(i) == 42 && text.getbyte(i + 1) == 47)
          i += 1
        end
        i += 2 if i + 1 < n
        next
      end

      ch = text.getbyte(i)

      if in_string
        if ch == in_string
          in_string = nil
        elsif ch == 92
          i += 1
        end
        i += 1
        next
      end

      if ch == 34 || ch == 39
        in_string = ch
        i += 1
        next
      end

      if ch == 123
        depth += 1
      elsif ch == 125
        depth -= 1
      end

      i += 1
    end

    block_end = i # points just after matching '}'
    block_inner = text[block_start...(block_end - 1)]
    full_rule = text[prelude_start...block_end]

    prelude_stripped = prelude.strip

    if prelude_stripped.start_with?("@")
      pruned_inner, removed_inner = prune_block(block_inner, unused_classes)
      removed_rules += removed_inner

      if strip_comments(pruned_inner).strip.empty?
        removed_rules += 1
        next
      end

      # If no inner changes, keep original
      if pruned_inner == block_inner
        out << full_rule
      else
        out << prelude
        out << "{"
        out << pruned_inner
        out << "}"
      end

      next
    end

    if removable_rule?(prelude_stripped, unused_classes)
      removed_rules += 1
      next
    end

    out << full_rule
  end

  [out, removed_rules]
end

css_files = Dir.glob(CSS_DIR.join("**", "*.css").to_s).map { |p| Pathname.new(p) }

grand_removed = 0

css_files.each do |path|
  original = path.read
  pruned, removed = prune_block(original, unused_classes)
  next if removed.zero?

  path.write(pruned)
  puts "Pruned #{path.relative_path_from(ROOT)}: removed rules=#{removed}"
  grand_removed += removed
end

puts "Done. Removed rules=#{grand_removed}."
